{
function incIntStr(str){
	var m = str.length;
    var k=m-1;
    while(k>=0 && str[k]==='9') k--;
    if(k>=0){
    	str = str.slice(0,k)
    		+ '123456789'[parseInt(str[k])]
    		+ '0'.repeat(m-k-1);
    } else str = '1' + '0'.repeat(m);
    return str;
}
function postproc(num,no_rounding,retain_plus){
	if(num===null)return;
	var n;
    // -- explicit signs
    if(num.sign === null)
    	num.sign = options['explicit-sign'] || null;
    else if(!retain_plus && num.sign === '+' && !options['retain-explicit-plus'])
    	num.sign = null;
    // -- remove leading zeros
    num.int = num.int.replace(/^00*/,'')
    // -- missing zeros
	if(!num.int) //&& options['add-integer-zero']
    	num.int = '0';
    if(num.sep && !num.frac) //&& options['add-decimal-zero']
    	num.frac = '0';
    // -- minimum integer digits
    n = options['minimum-integer-digits'] - num.int.length
    if(n>0)
    	num.int = '0'.repeat(n) + num.int;
    // -- rounding
    // TODO: disable rounding when non-digits present in number
	if(!no_rounding && num.uncert===null){ //&& options['round-mode']!=='off'
        if(true){//options['round-mode']==='figures')
        	n = num.int.replace(/^00*/,'').length;
            if(n)
            	n += num.frac.length;
            else
            	n = num.frac.replace(/^00*/,'').length;
        } else
        	n = num.frac.length;  // round-mode = places
        n -= 3; //options['round-precision'];
        switch(Math.sign(n)){
        case 1:
        	// Too many digits
            var comb = num.int + num.frac;
            var dir = Math.sign(parseInt(comb[comb.length-n])-5);
            if(!dir && n>1 && parseInt(comb.slice(1-n)))
            	dir = 1;
            comb = comb.slice(0,-n);
            if(!dir){
            	// exactly half
                switch(options['round-half']){
                case 'up': // actually: up in magnitude
                	dir = 1;
                    break;
                default:
                case 'even':
                	dir = parseInt(comb[comb.length-1])&1 ? 1 : -1;
                    break;
                }
            }
            if(dir===1) comb = incIntStr(comb);
            if(n<num.frac.length){
            	// decimal result
                num.int = comb.slice(0,n-num.frac.length);
                num.frac = comb.slice(n-num.frac.length);
            } else {
            	// integer result
                num.int = comb + '0'.repeat(n-num.frac.length);
                num.sep = null;
                num.frac = '';
            }
            break
        case -1:
        	// Too few digits
            if(num.sep || options['round-integer-to-decimal']){
            	num.sep = num.sep || '.';
            	num.frac += '0'.repeat(-n);
            }
            break
        };
    };
	if(
    	false //options['zero-decimal-to-integer']
        && !(num.frac && parseInt(num.frac))
    ) {num.frac=null;num.sep=null;};
};
function fmtDecimal(num){
  var integer = num.int;
  var fractional = num.frac;

  var gd = options['group-digits'];
  var md = options['group-minimum-digits'];
  var gs = '{' + options['group-separator'] + '}';
  var dm = '{' + (
  	options['copy-decimal-marker'] || true
    ? num.sep
    : options['output-decimal-marker']
  ) + '}';

  var sign = (num.sign || '');

//  integer = integer || '0';
  var l = integer.length;
  if(l>=md && (gd==='true' || gd==='integer')){
    l-=3;
    for(;l>0;l-=3){
	    integer = integer.slice(0,l) + gs + integer.slice(l);
    }
  }

  if(!num.sep)
	  return sign + integer;

  l = fractional.length;
  if(l>=md && (gd==='true' || gd==='decimal')){
    l-=1+(l-1)%3;
    for(;l>0;l-=3){
	    fractional = fractional.slice(0,l) + gs + fractional.slice(l);
    }
  }

  return (
    sign
  	+ integer
    + dm
    + fractional
  );
};

function fmtComplExp(num){
	var ob='',cb='';
    if(num.exp && options['bracket-numbers']){
    	ob = (options['open-bracket'] || '(') + ' ';
		cb = ' ' + (options['close-bracket'] || ')');
    }

	var re = num.re && fmtDecimal(num.re);
    var im = null;
    if(num.im){
    	var cr = (
          options['copy-complex-root'] || true
          ? num.im.root
          : options['output-complex-root']
        );
    	im = fmtDecimal(num.im);
        if(options['complex-root-position'] === 'before-number')
        	im = cr+im;
        else
        	im = im+cr;
    }
    var ret = num.rel ? num.rel+' ' : '';
    if(re !== null) {
    	if(im === null) ret += re;
        else ret += ob + re + ' ' + im + cb;
    } else if(im !== null) ret += im;
    else error('neither re nor im given'); // should never happen

    if(num.exp){
    	var exp = fmtDecimal(num.exp);
    	var oem = options['output-exponent-marker'];
    	if(oem)
        	ret += ' ' + oem + ' ' + exp;
        else
        	ret += (
            	' ' + (options['exponent-product'] || '\\times')
                + ' ' + (options['exponent-base'] || '10')
                + '^{' + exp + '}'
            );
    }
    return ret;
};

}

start = _ prod:Product _ {
	prod.forEach(function(fac){
    	var nums = [fac.num,fac.denom];
        nums = nums.map(function(num){
        	if(num===null)return num;
            // TODO: scientific-notation/fixed-exponent
        	postproc(num.re);
        	postproc(num.im,false,true);
        	postproc(num.exp,true);
            // TODO: retain-unit-mantissa retain-zero-exponent
            num = fmtComplExp(num);
        	return num;
        });
        fac.num = nums[0];
        fac.denom = nums[1];
    });
	return prod;
}

Product = head:MaybeQuotient tail:(_ Factor)* {
	var ret=[head];
    tail.forEach(function(f){ret.push(f[1]);});
    return ret;
}
Factor = 'x' _ num:MaybeQuotient {return num;}
MaybeQuotient = num:FullNum denom:(_ '/' _ FullNum)? {
	return {num:num, denom:denom && denom[3]};
}
FullNum = rel:(Rel _)? mantissa:ComplexOrRealWUncert exp:(_ Exponent)? {
	mantissa.exp = exp && exp[1];
    mantissa.rel = rel && rel[0];
	return mantissa;
}
ComplexOrRealWUncert = ComplexNum // / RealWUncert // TODO: this does not seem to work (tries to match ComplexNum even with '1 +- 1')
ComplexNum = re:((DblSign _)? DecimalWUncert) im:(_ DblSign _ ImaginaryNum)? {
	var res = re[0] && re[0][0];
    re = re[1];
    re.sign = res;
    var ims = im && im[1];
    im = im && im[3];
    if(im) im.sign = ims;
	return {
    	re: re,
        im: im,
    }
}
RealWUncert = sign:(DblSign _)? num:Decimal _ PM _ uncert:Decimal {
	var n = num.frac.length;
    var m = uncert.frac.length;
    num.frac = num.frac + '0'.repeat(Math.max(0,m-n));
    uncert.frac = uncert.frac + '0'.repeat(Math.max(0,n-m));
    num.uncert = uncert.int + uncert.frac;
    num.sign = sign && sign[0];
	return {re:num};
}

ImaginaryNum = ImaginaryNumPost / ImaginaryNumPre
ImaginaryNumPost = num:DecimalWUncert _ root:ComplexRoot {
	num.root = root; return num;
}
ImaginaryNumPre = root:ComplexRoot _ num:DecimalWUncert {
	num.root = root; return num;
}

ComplexRoot "complexRoot" = [ij]

Exponent = [eEdD] _ sign:(Sign _)? exponent:Decimal {
	exponent.sign = sign && sign[0];
    return exponent;
}

Sign = [+-] { return text(); }
PM = ('+-' / '\\pm') {return '\\pm';}
MP = ('-+' / '\\mp') {return '\\mp';}
DblSign = PM / MP / Sign

LL = ('<<' / '\\ll') {return '\\ll';}
LT = '<' {return '<';}
LE = ('<=' / '\\le' 'q'?) {return '\\le';}
GG = ('>>' / '\\gg') {return '\\gg';}
GT = '>' {return '>';}
GE = ('>=' / '\\ge' 'q'?) {return '\\ge';}
Rel = LL / LE / LT / GG / GE / GT

DecimalSep = [.,]

DecimalWUncert = num:Decimal uncert:(_ '(' _ Digits _ ')')? {
	uncert = uncert && uncert[3];
    num.uncert = uncert;
    return num;
}
Decimal "decimal" = DecimalWInt / DecimalNoInt
DecimalWInt = int:Digits rest:(_ DecimalSep (_ Digits)?)? {
	var sep = rest && rest[1];
    var frac = rest && rest[2] && rest[2][1];
    return {int: int, sep:sep, frac:frac || ''};
}
DecimalNoInt = sep:DecimalSep _ frac:Digits {
	return {int: '', sep:sep, frac:frac};
}

Integer "integer"
  = Digits { return parseInt(text(), 10); }

// TODO: siunitx interprets any symbol found in input-symbols
// as if they were digits.
Digits = [0-9]+ {return text();}

_ "whitespace"
  = [ \t\n\r]*            // TODO: retain-unit-mantissa retain-zero-exponent
